# Using django, django-rest-framework, and django-rest-datatables, to construct an API for the capitalism app

py -m venv capenv
pip install djangorestframework

pip install django
python.exe -m pip install --upgrade pip
django-admin startproject capitalism
cd capitalism
py manage.py startapp economy
py manage.py migrate
py manage.py runserver 
  works but no login because no users created

## commit initial commit with capitalism project, economy app, django and django-rest-datatables

Settings.py
  Add to INSTALLED_APPS
  Add Renderers
  Add loggers

economy/models.py
  add the Artist model (as a check)
  add the Commodities model
economy/admin.py
  register Commodity, Artist


OOPS
pip install djangorestframework-datatables

runs OK

## commit Commodity Model added
added meta to Model
created superuser (so we can use admin. can delete later so we can test without complications of authentication)

economy/serializers.py
  add Commodity serializer

economy/views.py
  add Commodity, Artist view #getalbumoptions will not work so commented out

OOPS
pip install django-filter

capitalism/urls.py
  added skeleton - admin and api

runserver
API loads from localhost/api

## commit added skeletal API

created templates/economy
  added base.html

# Decided to bring in all the material from the REST tutorial before proceeding

views.py
  added mixin classes

created economy/urls.py  
  added 'commodities/' and 'commodities/<pk>'

login and authentication
  added 'owner' to model.Commodity
  added UserSerializer to serializers.py
  added UserList and UserDetail to views.py
  added 'users/' and '/users/<pk>' to economy/urls.py
  wired up capitalism/urls.py to connect to economy/urls.py (wasn't done previously)
  added perform_create to the CommodityList view
  added owner= to CommoditiesSerializer
  add permission_classes to the CommodityList and CommodityDetail views

Some debugging

now allows us to access commodities via API

## Commit API working for commodities 

Create an endpoint for the root

Add the api_root function to views.py # ?Not very clear why this goes in views.py
Modify economy/urls.py to use api_root

Hyperlinking
  minor mods to serializer.py
  some debugging including naming urls

Seems to work OK

## Commit hyperlinking and root URL

Add ViewSets and Router

All seems to work

## Commit dunresting

## Add import facility

pip install django-adaptors
didn't work, out of date, uninstalled it

try [django-import-export](https://django-import-export.readthedocs.io/en/latest/installation.html)

pip install django-import-export

add as installed app in settings

create CommodityResource in admin.py (?why there?)

Can only export

pip import tablib

import-export integrated into admin with the help of [this](https://www.tutorialspoint.com/importing-data-into-models-in-django)

Names in the CSV have to be exactly the same as those in the model

Everything imported correctly except Project (case sensitive typo, correct next time around)

Table display not quite right (items to display changes nothing, etc) but basically working

## Commit Commodities imported and displaying

Add Project Model

## Commit Projects imported and displaying

Add TimeStamps

## Commit TimeStamps imported and displaying

Add Industries

## Commit Industries imported and displaying

Add Social Classes

## Commit Social Classes imported and displaying

Add Stocks

## Commit Stocks imported and displaying
## All data now defined, imported, and displaying

# Create Foreign Keys: Change the type of the Foreign Keys and see if they match up properly

First check we can display them all OK

Pages created for every table. 
  Need some kind of navigation
  Need to integrate them with the base, which will contain the navbar

## Commit pages for each table created

All nested inside base,html

TODO structure template directories properly
TODO name keys with FK correctly throughout

## Commit nested templates

Templates structured with navbar

## Commit navbar

Trying to change model to recognise all foreign keys.
They can be serialised, but cannot communicate the serialized references to datatables
eg in the ProjectSerializer I declare project_name and set it to serializers.CharField(source='project_FK.description',read_only=True)
This appears in the API output
but when I refer to it within commodities.html (as part of the datatables call) it says 'project_name not recognised' 

We will proceed to create foreign keys everywhere appropriate, in any case.

## Commit Commodities project foreign key converted to type 'models.ForeignKey'

ALL project foreign keys converted to type 'models.ForeignKey'

Decision: we'll just show the hyperlinks in the table displays. These are only to check the data in any case
Foreign keys display fine in admin, so we assume the models are set up correctly enough to proceed
Would be nice to have these hyperlinks clickable

## Commit All project_FKs converted to type 'models.ForeignKey'

We want to generate the key tables in Django and then render them into the template for Datatables to display
sandbox.html is a testbed for this
The first version is initialised within the script - [example taken from here](https://datatables.net/examples/data_sources/js_array.html)

## Commit sandbox display working with sample data provided on  datatables website

Pass datatable in the context of the sandbox function in views.py

Works OK (gives same result, not using the data yet)

Construct table inside sandbox and consume it with datatables script

Here, it gets the foreign key right. So that particular problem is solved.

The problem is now how to do all the complex processing required to produce the table. 
Should this be done server side or client side?
Would be better, if we want to do it client side, to pass a simple array to js.
This is because, as I understand it, js doesn't know about querysets

## Commit sandbox display working with data from the commodity query

Foreign key to Commodities inserted into industries model, and directly edited into the industries table
Minor mod: 'self' now displays the project # for the main tables. Makes it easier to edit the FK in admin
Data Dump to fixtures

## Commit Commodity Foreign Keys in place in Industry Table

TODO: export the data maybe somewhere else too

Start now trying to build the main table
But first, we need to put in a project selector

Experiment with [Django-filter](https://www.youtube.com/watch?v=nle3u6Ww6Xk) 
[see also the URL filter which we probably won't use but hey](https://django-url-filter.readthedocs.io/en/lat est/index.html)
and see [bootstrap form](https://django-bootstrap-form.readthedocs.io/en/latest/)

pip install django-filter # but it says all requirements met
pip install django-bootstrap-form
 

This is now displaying the form, though it's still doing it with the made-up fields
However, we'll now try doing things a different way.

First, re-organise the structure to be like [The minimalist boilerplate](https://htmx-django.com/blog/a-minimalistic-modern-django-boilerplate)

* Rename outer folder to 'root' so it doesn't get confused with the project
* Create 'templates' folder in /root
* Move 'base.html' into it
* Add   str(BASE_DIR.joinpath("templates")) to TEMPLATES["DIRS"]
* Move all the templates there.
Did not quite work, because the Economy ListView autogenerates a reference to economy/templates.industry_list.html
And I couldn't figure out the correct path to assign to the template_name variable in the ListView class.

Anyhow: create a new Model to contain the current state of the project.
This (initially) has  only two fields, being the project and the timestamp

Let's call it State.
Create one instance of it using admin
Called 'Initial' with 
  * project_name=1
  * time_stamp=1

Now we want to use this to filter the queryset used by the Economy Class

This is done by modifying EconomyView and industry_list.html

## Commit initial model with project selection now working

Now try to display the productive commodities
For this, we need to iterate over the Industries, which requires us to convert the Stocks.owner_industry_or_class into a Foreign Key
And it's more complicated, because in reality we want two tables with two foreign keys
* an Industry_Stocks table with a foreign key to Industries
* a SocialClassStocks table with a foreign key to SocialClass

We'll try to do this all at one go. But first a commit

## Commit prior to Stocks Table Split

Created industry_stocks table
Added to serialisers, admin, views, urls
Created industry-stocks.html
Added button to navbar to view this API
* TODO debug this
Populated Project 1
* TODO complete the population (time-consuming, can we do in bulk? Also we may abandon API technique so not worth the time)

The table is almost working but the code is ramshackle
* TODO maybe pass .value lists to the template instead of querysets?
* GIVE UP is there a coding trick like 'cycle' to avoid interrogating the whole stock list just to pick out those corresponding to the industry row?
* TODO sales and money stocks
* DONE find out which options in datatables remove the pagenation and search, which are superfluous

## Commit First stab at the working display table

Refinements

  IndustryStock remove industry_name (picked up from Industry_FK)
  Create Sales Stock as an FK in Industry
  Create Money Stock as an FK in Industry
  Transfer all industry Stocks from Stocks to IndustryStocks
  Edit the Industry objects so they refer to the correct Sales and Money stocks

TODO
* test consistency of Project FK
* test consistency of the Stocks (of all types) with the industry they belong to
* test consistency of commodity type (Money, Sales, Productive)
* do we really need the Stock to refer to the industry it is in? It's kind of useful for the purposes of doing summations and the like
* stock type should be a choice field

Projects 1,2,3,4,5, and 8 transferred to Industry Stocks

Now convert the remainder to Social Classes
## Commit Industry Stocks Created, projects 6 and 7 removed

Now save all the data

Created Fixtures files in fixtures directory
and Exported each Model as xlsx in static/datadumps

## Commit Datadump

Now convert the Social-classes model to accept Stocks
* Rename Stocks to be SocialStocks
The table has emptied
Rather than backtrack, let's see if we can re-import it

Yippee.

Now fix the social-class model field names
And eliminate the spurious (and confusing) production_quantity field
Also eliminate the equally spurious and confusing consumption_quantity field from industry-stocks

Done: neither the IndustryStocks nor the SocialStocks tables display correctly
But we'll fix this on a sweep through to sort out the serialization

Re-organise the buttons to make things a little tidier

## Commit minor improvements to layout

TODO are the stock-industry and stock-socialclass relations one-one? In which case there is a lot of redundancy at present

New Datadump and switch to PostGres

pip install psycopg

Couldn't get it working because of bug on migrating Project ('duplicate defaults')
Leave for now until we either get a solution, or start over in a new folder

Some Tidying

## Commit Some Tidying

Modifications to Social Class
* Added Money, Consumption, Labour Power fields to the SocialClass model
* Completed the specification of Social Stocks
* In Admin, filled out the foreign keys in Social Stocks
* In Admin, filled out the foreign keys in Social Classes

This all displays correctly. 
TODO allow for a variety of consumption goods (BIG DEAL)
* at present this arises only in the three-department IIa and IIb model, where the capitalists consume luxuries and the workers consume necessities.

There are now some redundant fields in social-stocks and probably in industry-stocks.

However, time to take a commit and a data dump

## Commit Social Class table displaying and data dump

Now we want to start making the actions

First step is a simple button that carries out the very first action in C-P-C

This is Exchange >Calculate Demand

For this, we have to study the Capitalism 9.0 JavaFX model, which was working.


# Planning for the action toolbar

We will have a set of buttons that take the user through all the stages of the C-M-C circuit
These are further broken down into calculation stages, which are visible to the user so she can track the calculations

The stages are (vertically here):

* C - M - C : Exchange. in this stage, actors (industry owners and classes) exchange what they have in order to produce (industries) and reproduce (classes)

  * Estimate demand
    * Add up all demand from industries to produce at their current level, given the money at their disposal
    * Add up all demand from social classes to reproduce, given the money at their disposal
  * Constrain supply
    * Check the sales stocks of the suppliers of each good
    * If this is lower than demand, and there is more than one supplier, calculate the fraction of each source demand that will be satisfied.
    * If this is higher than demand, and there is more than one supplier, calculate the fraction of the sales stock of each supplier than will be realised
  * Trade. Purchasers use their money stocks to acquire stocks.

* C - P...C'. Produce. Includes calculation of new Values
  * For each industry, set the production level according to the maximum possible given input stocks
  * For each industry, produce:
    * Transfer output physically to sales
    * Calculate the value of sales stock ('individual' value, not yet socialised)
  * For the social classes, reproduce (note that in Capitalism 9.0 this was a separate stage after re-pricing - this is to be thought about. It doesn't affect how well they succeed, but can affect the price of labour power):
    * Consume available stocks (at the level determined by the (user-defined) consumption needs of that class
    * For workers, increase the stock of labour power accordingly
      * Note that there are a variety of assumptions governing how well they succeed
    * For capitalists, they don't supply anything but their ranks may be thinned...
      * Note that there are a variety of assumptions governing how well they succeed
    * The current simulation is 'stock-driven'. In general, we suppose that classes and industries have a certain level of stocks above their actual needs. A rise or fall in stocks will generate a price signal and this will regulate the system dynamically. We know this works because that was the algorithm used in the very first version.
    * In most of the projects currently in the simulation, price dynamics have not been introduced. Therefore, we have focussed on very simple allocation mechanisms that essentially ensure stocks do not fall below zero.
  * Calculate social values and prices
    * Note that there are a variety of assumptions governing how prices are affected by values
    * for example, profit equalization, price dynamics, etc
  * Revalue and reprice all stocks
* C' - (C, V, s). Distribute.
  * The main issue here is the disposition of the surplus s. C and V are taken care of in the first stage of the next cycle
  * The capitalist class becomes the owner of the money form of s
  * Profit (calculated as the increase in the value of each industry) is therefore transferred from the industry to the capitalist class. To be precise, a part is transferred for their consumption needs, and the rest stays in the industry.
  * At this stage, we haven't yet developed a variety of capitalists, or a credit system as such
  * Therefore, the decision to accumulate is quite primitive. It is open to improvement and the framework for so doing is present in the design.
  * At the current stage of development we simply assume that any money not needed to maintain capitalist consumption is retained in the industry concerned
  * We then have to determine how this is ued
  * Again, the simulation is unsophisticated but the framework provides for a variety of mechanisms.
  * At this stage in development, we simply suppose that the industry owner will attempt to use all the money that has been accumulated in the business, to expand the business. The 'desired production level' will therefore be elevated by increasing the 'current level' as high as possible, given the cost of acquiring the additional inputs


## Renaming/Redesign
* State
  * Convert Project to a foreign key DONE
  * Convert time-stamp to a foreign key DONE
  * Add 'owner' field to 'State' (for consistency) DONE
* Project
  * Either remove the id field from Project or add it to everything else (for consistency) DONE (removed)
* Commodity
  * origin_type should be renamed to 'origin' and made a choice field (Social, Industrial, Money) DONE
  * function_type should be renamed to 'usage' and made a choice field (Consumption, Production, Money) DONE
  * need a new field 'Demand' which will hold the total demand for this commodity at the exchange stage DONE
  * need a new field 'Supply' DONE
  * need a new field 'Allocation Proportion' which will hold the proportion of demand that can be satisfied DONE
* Industry
  * 'industry_name' should just be 'name' DONE
* Social Class
  * social_class should be 'name' DONE
* IndustryStock
  * 'stock-type' should be renamed to 'type' DONE
  *  and made a choice field (Productive, Sales, Money) TODO - might involve a lot of work 
  * 'stock-size' should be renamed to 'size' DONE
  * 'production_quantity' should be renamed to 'production_requirement' DONE
* SocialStock  
  * 'social_class' field is superfluous I think. Delete after checking this
  * 'stock_type' just becomes 'type' and is a choice field (Consumption, Sales, Money) TODO - might involve a lot of work 
  * 'quantity' becomes 'size' DONE
  * 'consumption_quantity' becomes 'consumption_requirement' DONE
* Time Stamp
  * super-state should be a choice field (Exchange, Production, Distribution) TODO
  * description should be renamed 'sub-state'.  too complicated to make it a choice field but it should say what calculation was undertaken (eg 'Exchange:Demand') TODO

  ## Datadump
  ## Commit after model tweaks and datadump

Step 1 Estimate Demand

Sum of two things
  * What each industry expects of each of its productive stocks, to produce at the current level.
    * This is in turn the difference between the stock it now has, and the stock it needs, to produce at this level
  * What each social class expects from consumption, to satisfy its needs
    * This is in turn the difference between the stock it now has, and the stock it requires, to satisfy its needs

  
# Parenthesis - rename the api views
# Parenthesis - create normal (generic) ListViews for all the tables
# Parenthesis - convert SocialStock.commodity to a Foreign Key
# Parenthesis - data dump (all data transformed and/or entered)

## Commit Data Entry and Display Complete + data dump

# End of Parenthesis

Step 1 Estimate Demand

We will depart from the Capitalism 9.0 assumption of minimal stocks, and so will increase turnover time to 2 for the project 1 commodities
This means that the sales stocks will have to be doubled

So

  Initialise commodity demand to zero

  For each productive industry stock, demand is 
    production_requirement * turnover_time - size
  For each consumption social stock, demand is 
    consumption_requirement - size
  We store these demands in the stocks
  And we add it to the demand for the commodity concerned

  This means we need demand fields for both types of stocks, and for the commodity.
  So, add these to the models and the tables DONE

  Now we need some action buttons
  Start with an 'exchange' button

## Commit Demand Button calculates demand. Supply not yet done

So for demand
  Initialise commodity supply to zero
  For each industry, supply is
    industry.sales
  For each social class, supply is
    socialclass.labourpower.size

TODO a field to estimate consumption demand relative to population size
TODO buttons should show their state

## Commit debug of supply and demand (commodity not saved properly); made a start on allocate

Made a start on 'allocate'; some debugging

## Commit started allocate; some more debugging. Supply and demand now match (for project 1 in which this is the intention)
## Commit Allocation is correct as far as we have got; we will now move on to exchange

Created abstract base class for Stocks
Tested - tables display OK
There is some problem with allocate, which should be looked at

## Commit created abstract base class for stocks

## Data Dump (Fixtures only)

Created abstract base class for Industries and Social Classes
Tested
  - tables display OK
  - action buttons work OK

TODO systematic treatment of money and sales

## Commit created abstract base class for Industries and Social Classes

Corrected bug that sales commodity for social classes was consumption goods
Now it is Labour Power. Looks a bit odd in that capitalists don't contribute any (though they might if petty commodity producers)
 but we handle this by saying that though they could sell Labour Power, in the projects so far under study, they don't actually contribute any

Note that we can't under the present system abstract the money and sales stocks of SocialClass and Industry
 To do that, I think we'd have to drop having StockOwner as an abstract class
 but this involves losing and reconstructing all the data, so leave for now

TODO Allocate still doesn't seem to be reporting correctly so fix this first, then deal with exchange DONE
Allocate was functioning correctly but the reporting was misleading

## Datadump
## Commit sorted minor problems with reportage; completed allocation to include social classes, datadump done

Now we'll try moving to postgres using loaddata
 * Did not manage to migrate to PostGres
 * Did manage to dump and restore data to a clean SQLite database, using loaddata with fixtures.json
 * Deleted all old migration and fixture files but kept the xlsx exports, just in case

## Commit dump and restore fixtures working

# Plan for 'purchases' action.

Iterate through all stocks other than money and sales (that is, all production and consumption stocks)
 * If a stock has a demand that needs to be satisfied it belongs to a buyer
   * Identify the owner. This is the 'buyer'
   * The stock we can call 'buyer_stock'
   * Find the buyer's money stock. This is 'buyer_money_stock
 * From the stock's commodity, we can find all sellers of the stock that the stock is trying to buy
  * Iterate through these
   * Identify the owner. This is the 'seller'
   * the stock we can call 'seller_stock
   * Find the seller's money stock. Tbis is the 'seller_money_stock'

Identify the amount to be transferred, which is the minimum of buyer_stock.demand and seller_stock.supply
Call this 'transferred_stock'

From the commodity we can find the unit price. 
Call this 'stock_price'

   * the transaction is then
    * increase buyer_stock.size by transferred_stock
    * decrease seller_stock by transferred_stock
    * decrease buyer_money_stock by transferred_stock.size * stock_price
    * decrease seller_money_stock by transferred_stock.size * stock_price

TODO a problem is what to do if the buyer has insufficient money.
This should be dealt with at allocation time

DONE: skeleton of trade is written
TODO: 
  * we have to work out at what point, and how, the time-stamp will move forward in such a way that the
  * algorithm will pick up everything correctly

## Commit Sales processed as far as possible; next step is to deal with the time_stamp advance process

Sketch of time_stamp advance

* Create a new time-stamp record which will be a copy of the existing record but with time_stamp advanced by one
* Modify the State record so it now holds the new time stamp. Think of a suitable name (this should probably be a descriptive parameter supplied by calling process)
* (think about the comparator_state etc - for now, we just want to get the advance process working, deal with history later)
* For all other objects, create a completely new record with the new time-stamp, and save it

Notes on time_stamp advance
* we should advance by one at the initialization stage. That way we can always go back to the start
* initialise should have an action button
* initialization should first wipe out all records with time-stamps greater than 1
* time stamp should advance before each 'superstate'

Notes on initialise
*It should be sufficient to delete, from every object, anything with time stamp greater than 1
*and reset State to timeStamp 1

CHANGED MODELS TO GET CASCADED DELETES, OTHERWISE WE GET FOREIGN KEY ERRORS
Almost there, but the cascade deletes some records from earlier time stamp (in social classes)
This is most likely because of an error in move_one_step
So we will return to fixing that

## Commit Initialize almost working; move one step seems to be faulty

Reached the limits of what can be done with the present model and data input methods
Will now migrate to 10.3

## Commit final commit: on to 10.3
